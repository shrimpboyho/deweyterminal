{"ts":1363645831741,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\n Copyright (c) 2012 Alan Lindsay - version 2.7.5\n\n Permission is hereby granted, free of charge, to any person obtaining\n a copy of this software and associated documentation files (the\n \"Software\"), to deal in the Software without restriction, including\n without limitation the rights to use, copy, modify, merge, publish,\n distribute, sublicense, and/or sell copies of the Software, and to\n permit persons to whom the Software is furnished to do so, subject to\n the following conditions:\n\n The above copyright notice and this permission notice shall be\n included in all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n(Kernel = function() {\n\n  var core, hubs = { }, modules = {}, registered = {},\n      listeners = {},\n      defaultHub = 'main';\n\n  // Forces a string to an array\n  function strToArray(str) {\n\n    if (isString(str)) str = [str];\n\n    return str;\n  }\n\n  function isString(str) {\n\n    return Object.prototype.toString.call(str) == '[object String]';\n  }\n\n  // Should only used for Kernel, modules and hubs\n  function decorateMethods(obj, proto) {\n\n    var key, method;\n\n    if (!obj) return;\n\n    for (key in obj) {\n\n      if (obj.hasOwnProperty(key) || proto) {\n\n        if (key === 'decorateMethod' || key === 'decorateMethods') return;\n\n        if (!obj._decoratedMethods) obj._decoratedMethods = {};\n\n        if (!obj._decoratedMethods[key]) {\n\n          method = obj[key];\n\n          if (typeof method === 'function') {\n\n            // Reassign method\n            obj[key] = core.decorateMethod(obj, key, method);\n\n            // Track decorated methods for later decoration calls\n            obj._decoratedMethods[key] = true;\n          }\n        }\n      }\n    }\n  }\n\n  function setDefaultHub(name) {\n\n    defaultHub = name;\n  }\n\n  function mergeParents(module) {\n\n    var parents, parent, merged = {};\n\n    if (module.extend) {\n\n      // Cast to array\n      parents = strToArray(module.extend);\n\n      for (i=0; i<parents.length; i+=1) {\n\n        // Create module instance\n        parent = parents[i];\n        parent = modules[parent];\n\n        if (parent) Kernel.extend(merged, parent, true);\n      }\n    }\n\n    return Kernel.extend(merged, module, true);\n\n  }\n\n  function defineModule(name, Definition) {\n\n    // Expand defintion (include parents)\n    modules[name] = mergeParents(Definition);\n\n  }\n\n  function defineHub(name, Definition) {\n\n    // Create instance\n    var broadcastCount = {event: 0}, callbackCount = {event: 0},\n        totalElapseTime = {event: 0}, h = Definition;\n\n    h._internals = { type: 'hub' };\n    h.id = name;\n\n    // Add built-in methods - these override any definition methods\n    h.broadcast = function(type, data, callback, id) {\n\n      var i, l, e = listeners.event, size, eventData,\n          start, diff, elapseTime = 0, listenerData = [], mutate;\n\n      // Hook in for debugging or mutation purposes\n      if (h.beforeBroadcast) {\n        mutate = h.beforeBroadcast(type, data, id);\n\n        if (mutate.type) type = mutate.type;\n        if (mutate.data) data = mutate.data;\n      }\n\n      // Get the listeners\n      l = listeners[type];\n\n      // Increment the broadcastCount\n      broadcastCount[type] = broadcastCount[type] || 0;\n      broadcastCount[type] += 1;\n      broadcastCount.event += 1;\n      callbackCount[type] = callbackCount[type] || 0;\n      totalElapseTime[type] = totalElapseTime[type] || 0;\n\n      // Cycle through the listeners and call the callbacks\n      if (l) {\n\n        for (i=0,size=l.length; i<size; i+=1) {\n\n          // Measure how long it takes to complete\n          start = (new Date()).getTime();\n\n          listeners[type][i].callback(data, id);\n\n          diff = (new Date()).getTime() - start;\n          elapseTime += diff;\n          totalElapseTime[type] += diff;\n          totalElapseTime.event += diff;\n\n          // Increment the listener count\n          callbackCount[type] += 1;\n          callbackCount.event += 1;\n\n          listenerData.push({\n            id: listeners[type][i].id,\n            elapseTime: diff,\n            callback: listeners[type][i].callback\n          });\n        }\n      }\n\n      // Now cycle through the 'event' event listeners\n      if (e) {\n\n        eventData = {\n          type: type,\n          data: data,\n          time: new Date(),\n          listeners: listenerData,\n          broadcastCount: broadcastCount[type],\n          callbackCount: callbackCount[type],\n          elapseTime: elapseTime,\n          totalElapseTime: totalElapseTime[type],\n          all: {\n            broadcastCount: broadcastCount.event,\n            callbackCount: callbackCount.event,\n            totalElapseTime: totalElapseTime.event\n          }\n        };\n\n        for (i=0,size=e.length; i<size; i+=1) {\n          listeners.event[i].callback(eventData);\n        }\n      }\n\n      // Handle callback if provided\n      if (callback) callback();\n    };\n\n    // Provide an authorization method if not present.\n    // Everything is authorized by default.\n    h.authorized = h.authorized || function(type, moduleId) { return true; };\n\n    h.listen = function(type, callback, moduleId) {\n\n      // If not a module then store in hub id\n      moduleId = moduleId || 'hub-'+h.id;\n\n      var i, size, t;\n\n      // Cast to array if string\n      type = strToArray(type);\n\n      for (i=0,size=type.length; i<size; i+=1) {\n\n        t = type[i];\n\n        // Only setup callbacks if authorized\n        if (h.authorized(type, moduleId)) {\n          // Force array\n          listeners[t] = listeners[t] || [];\n          listeners[t].push({callback: callback, id: moduleId});\n        }\n      }\n    };\n\n    h.getStats = function() {\n      return {\n        broadcastCount: broadcastCount,\n        callbackCount: callbackCount,\n        totalElapseTime: totalElapseTime\n      };\n    };\n\n    h.share = function(obj) {\n\n      Kernel.extend(h, obj);\n    };\n\n    // Decorate during instatiation\n    decorateMethods(h);\n\n    // Store hub in hubs array\n    hubs[name] = h;\n  }\n\n  // This checks for DOM nodes and 3rd party lib objects that should not be deep copied\n  function skipDeepCopy(obj) {\n\n    try {\n\n      // Put other libs here if desired\n      if (obj instanceof RegExp) return true;\n      if (obj instanceof Node) return true;\n      if (obj instanceof jQuery) return true;\n\n    }\n    catch (e) {\n      // In order to run in non-DOM environments like node.js\n    }\n\n    return false;\n  }\n\n  function extend(obj1, obj2, deep, proto, mergeArrays) {\n\n    var key, i, l;\n\n    // Filter out null values\n    if (obj2 === null) return obj1;\n\n    // Reset arrays and objects if needed\n    if (typeof obj1 !== \"object\" || !obj1) obj1 = (obj2 instanceof Array) ? [] : {};\n\n    // Force deep extend & decoration for hubs and modules\n    if (obj1._internals && (obj1._internals.type === 'module' || obj1._internals.type === 'hub') ) {\n\n      deep = true;\n      decorateMethods(obj1, true);\n    }\n\n    // Empty arrays unless otherwise specified\n    if (obj1 instanceof Array && obj2 instanceof Array && (!mergeArrays)) {\n\n      // empty the target array so as not to leave behind extra values\n      obj1 = [];\n    }\n\n    // Loop through the keys\n    for (key in obj2) {\n\n      if (obj2.hasOwnProperty(key) || proto) {\n\n        // Skip duplicates, internals and recursive copies\n        if (obj1[key] === obj2[key]) continue;\n        if (key === '_internals') continue;\n        if (key === '_parent') continue;\n        if (key === '_children') continue;\n        if (obj1 === obj2[key]) continue;\n\n        // Skip recursive hub references\n        if (key === 'hub' && obj2[key]._internals && obj2[key]._internals.type === 'hub') continue;\n\n        // Handle special objects (RegExp, Node, jQuery, etc.)\n        if (skipDeepCopy(obj2[key])) {\n          obj1[key] = obj2[key];\n          continue;\n        }\n\n        // Handle recursion\n        if (deep && typeof obj2[key] === 'object') {\n\n          obj1[key] = Kernel.extend(obj1[key], obj2[key], deep, proto, mergeArrays);\n        }\n        else {\n\n          if (obj1._internals && obj1._internals.type === 'Kernel') {\n\n            // Disallow overwriting base objects\n            switch (key) {\n              case 'extend':\n              case 'decorateMethods':\n              case 'module':\n              case 'register':\n              case 'hub':\n              case 'start':\n              case 'stop':\n              case 'version':\n              case '_internals':\n                throw \"You can't extend '\"+key+\"', it's part of Kernel's base functionality.\";\n\n              default:\n              // Assignment below\n            }\n          }\n          else if (obj1._internals && obj1._internals.type === 'module') {\n\n            // Disallow overridding module ids\n            if (key === 'id') throw \"You can't overwrite a module instance id. [\"+obj1.id+\"]\";\n          }\n\n          // Merge arrays, don't override indexes blindly\n          if (obj1 instanceof Array && obj2 instanceof Array && mergeArrays) {\n\n            // Filter out duplicates\n            for (i=0, l=obj1.length; i<l; i+=1) {\n              if (obj1[i] === obj2[key]) continue;\n            }\n\n            // Add non-duplicates\n            obj1.push(obj2[key]);\n          }\n          else {\n            // Make the assignment\n            obj1[key] = obj2[key];\n          }\n        }\n      }\n    }\n\n    return obj1;\n  }\n\n  // This will create a module instance - but it won't call its init method.\n  function registerModule(id, type, hub, config, core) {\n\n    var hub = hub || defaultHub, instance;\n\n    registered[id] = {\n      hub: hubs[hub],\n      started: false,\n      Definition: modules[type]\n    };\n\n    // Create a module instance\n    try {\n      instance = Kernel.extend(mergeParents(registered[id].Definition), registered[id].Definition, true);\n    }\n    catch (e) {\n      throw \"Couldn't register module: [\"+id+\"] - missing or broken Definition: \"+e.message;\n    }\n\n    // Merge config into instance\n    if (config) Kernel.extend(instance, config, true);\n\n    // Add built-ins\n    instance._internals = { type: 'module', moduleType: type };\n    instance.kill = instance.kill || function() {};\n    instance.id = id;\n\n    // Setup access to the hub\n    var H = function() {};\n    H.prototype = registered[id].hub;\n\n    instance.hub = new H;\n    instance.hub.broadcast = function(type, data, callback) {\n      registered[id].hub.broadcast(type, data, callback, id);\n    };\n    instance.hub.listen = function(type, callback) {\n      registered[id].hub.listen(type, callback, id);\n    };\n    instance.hub._internals = Kernel.extend(registered[id].hub._internals, { moduleId: id, moduleType: type });\n\n    // Decorate methods\n    decorateMethods(instance, true);\n\n    // Save the instance\n    registered[id].instance = instance;\n\n    // execute callbacks if provided\n    if (core.onRegister) core.onRegister(registered[id].instance);\n    if (registered[id].instance.onRegister) registered[id].instance.onRegister();\n  }\n\n  // Automatically regsiters modules assigning ids based on the provided function\n  function autoRegisterModules(fn) {\n    \n    var type;\n    \n    fn = fn || function(type) {\n      return type.toString().replace(/([a-z])([A-Z])/g, \"$1_$2\").toLowerCase();\n    }\n    \n    for (type in core._internals.modules) {\n      core.register(fn(type), type);\n    }\n    \n  }\n\n  function unregisterModule(id) {\n\n    // Stop the module if started\n    if (registered[id].instance.started) Kernel.stop(id);\n\n    delete registered[id];\n  }\n\n  function startModule(id, config, core) {\n\n    if (core.module.isStarted(id)) return;\n\n    // Merge config into instance\n    if (config) extend(registered[id].instance, config, true);\n\n    // Set module as started\n    registered[id].started = true;\n\n    // Initialize the module\n    return core.onStart(registered[id].instance);\n  }\n\n  core = {\n    extend: extend,\n    decorateMethods: decorateMethods,\n    module: {\n      define: defineModule,\n      get: function(id) {\n\n        if (!registered[id]) throw \"Couldn't get instance for: \"+id+\", is it registered?\";\n\n        return registered[id].instance;\n      },\n      getDefinition: function(type) {\n        return modules[type];\n      },\n      isStarted: function(id) {\n        return registered[id].started;\n      }\n    },\n    hub: {\n      define: defineHub,\n      get: function(id) {\n        return hubs[id];\n      }\n    },\n    register: function(id, type, hub, config) {\n\n      var i;\n\n      // Check to see if an array is being used\n      if (isString(id)) {\n\n        registerModule(id, type, hub, config, this);\n      }\n      else {\n        // Register all the modules\n        for (i=0; i<id.length; i+=1) {\n\n          registerModule(id[i].id, id[i].type, id[i].hub, id[i].config, this);\n        }\n      }\n    },\n    unregister: unregisterModule,\n    autoRegisterModules: autoRegisterModules,\n    start: function(id, config) {\n\n      var i;\n\n      // Check to see if an array is being used\n      if (isString(id)) {\n\n        return startModule(id, config, this);\n      }\n      else {\n        // Start all the modules\n        for (i=0; i<id.length; i+=1) {\n\n          startModule(id[i].id, id[i].config, this);\n        }\n      }\n    },\n    startAll: function() {\n\n      var key;\n\n      for (key in registered) {\n\n        startModule(key, null, this);\n      }\n    },\n    onStart: function(instance, callback) {\n      instance.init();\n      if (callback) callback();\n    },\n    decorateMethod: function(instance, name, method) {\n\n      return function() {\n\n        // Bind instance methods\n        return method.apply(instance, arguments);\n      };\n    },\n    stop: function(id) {\n\n      var key, i, size, listener;\n\n      // Call the module kill method first\n      this.onStop(registered[id].instance);\n\n      // Wipe out any listeners\n      for (key in listeners) {\n\n        // Cycle through each type\n        for (i=0,size=listeners[key].length; i<size; i+=1) {\n\n          listener = listeners[key][i];\n\n          if (listener.id === id) listeners[key].splice(i, 1);\n        }\n      }\n\n      // Flag the module\n      registered[id].started = false;\n    },\n    onStop: function(instance) {\n      instance.kill();\n    },\n    version: '2.7.5',\n    _internals: {\n      PRIVATE: 'FOR DEBUGGING ONLY',\n      type: 'Kernel',\n      hubs: hubs,\n      modules: modules,\n      registered: registered,\n      listeners: listeners\n    }\n  };\n\n  return core;\n\n}());\n\n// Define main hub\nKernel.hub.define('main', {});\n"]],"start1":0,"start2":0,"length1":0,"length2":14886}]],"length":14886}
